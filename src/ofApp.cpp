#include "ofApp.h"

//--------------------------------------------------------------
// ofApp() 객체를 생성할 때 호출되는 함수 -> 리소스나 렌더링할 대상(메쉬)를 생성하기 적합한 곳.
void ofApp::setup(){
    /*
     ofMesh 객체를 triangle 이라는 변수에 넣어 새롭게 생성함.
     
     근데 왜 이거를 선언해놨다가 주석처리 했을까?
     
     이거를 아래에 있는 ofApp의 draw() 함수에서도
     가져가서 그 안의 .draw() 함수를 호출해야 실행창에서 실제로 메쉬를 렌더링할 수 있음.
     
     근데 draw() 함수에서는 그냥 바로 triangle 변수에 접근을 못함.
     왜? draw() 함수에서 선언한 변수가 아니니까!
     
     이 변수에 접근하고 싶으면, .h 라고 되어있는, cpp 언어에서
     '헤더 파일' 이라고 하는 파일에다가 변수를 선언해주면 됨.
     
     이게 뭐냐면 cpp 에서는
     함수 및 변수의 declaration (선언) 과 definition (정의) 를
     각각의 파일에 나눠서 사용하는 경향이 있음.
     
     즉, .h 인 헤더파일에서는 함수나 변수를 선언만 해주고,
     그 안의 디테일한 로직을 정의하는 건 .cpp 파일에서 해준다는 거임.
     
     이렇게 선언파트를 따로 분리해두면 뭐가 좋냐면,
     .cpp 파일들이 각자 독립적인 컴파일 프로세스, 즉 독립적인 빌드가 가능하다는 것임.
     
     자세한 내용은 유튜브에서 <헤더파일의 의미> 영상 참고할 것.
     
     암튼, 지금 서로 다른 블록의 함수들에서 동일한 ofMesh 객체가 담긴 변수
     triangle 을 사용하고 싶은 거니까, 해당 변수의 선언을
     헤더파일인 ofApp.h 로 옮기면 ofApp의 draw() 함수 안에서도
     triangle 에 접근할 수 있게 됨.
     **/
    // ofMesh triangle;
    
    triangle.addVertex(glm::vec3(0.0, 0.0, 0.0));
    triangle.addVertex(glm::vec3(0.0, 768.0, 0.0));
    triangle.addVertex(glm::vec3(1024.0, 768.0, 0.0));
}

//--------------------------------------------------------------
void ofApp::update(){

}

//--------------------------------------------------------------
// setup() 함수에서 생성한 메쉬들을 실행창 화면에 실제로 그리려면,
// 이 draw() 함수 내에서 각 메쉬들 내부에 존재하는 ofMesh.draw() 내장함수들을 호출해줘야 함.
// 이 draw() 함수는 매 프레임마다 호출되는 three.js 에서 사용하던 렌더링루프 함수랑 똑같다고 보면 됨.
// 매 프레임마다 GPU 에 뭘 그리라고 명령할건지, 그 명령할 내용들을 담아주는 렌더링루프 함수!
void ofApp::draw(){
    /**
     ofMesh 객체인 triangle에도 .draw() 함수가 따로 존재함.
     
     이거는 뭐냐면, 특정 프레임에 해당 메쉬를 실행창에 그려주라고
     GPU 에 명령을 내리는 내장함수로 보면 됨.
     
     이거를 ofApp 의 draw 함수에서 실행하기 위해 triangle 에 대한 접근이
     필요했던 것이고, 그래서 triangle 변수를 헤더 파일에서 선언해준 거임.
     */
    triangle.draw();
}

//--------------------------------------------------------------
// 키보드 입력을 받으면 호출되는 함수
void ofApp::keyPressed(int key){
    /**
     키보드 입력을 받으면 triangle 메쉬에서 2번째 인덱스의 버텍스,
     즉, 맨 마지막에 추가한 버텍스(0, 1, 2 니까)를 가져와서,
     걔의 y좌표값을 -20 씩 감소시킴으로써, 현재 사용중인 스크린 픽셀 좌표계가
     어떻게 이루어져있는 것인지 확인하기 위한 것임.
     
     이걸 왜 해주냐면, 오픈프레임웍스는 셰이더를 별도로 지정하지 않으면
     기본 셰이더를 적용해주는데, 이 기본 셰이더가 '스크린 픽셀 좌표계' 를 기준으로
     버텍스 좌표를 잡아주고 있음.
     
     근데 이 스크린 픽셀 좌표계는, 마치 2DCanvas 나 DOM 좌표계처럼
     좌측 상단이 (0, 0) 이고, y축이 아래로 갈수록 늘어나는 구조로 되어있어서
     일반 3D 좌표계와 다르다는 것을 인지하기 위해 해보는거임.
     
     지금 아무 키나 누를 때마다 마지막에 추가한 버텍스, 그니까 우측 하단 버텍스를 가져와서
     (0, -20, 0) 버텍스와 더해주는, 그니까 y좌표값을 -20씩 빼주고 있는거임.
     
     이렇게 해서 해당 버텍스가 키를 누를 때마다 어디루 가는지 보면서
     스크린 픽셀 좌표계에서 y축이 어떻게 생겨먹은건지 파악할 수 있음.
     */
    glm::vec3 curPos = triangle.getVertex(2); // 2번째 인덱스의 버텍스, 즉, 마지막에 추가한 버텍스를 가져와서 curPos 에 저장해 둠.
    // triangle.setVertex(2, curPos + glm::vec3(0, -20, 0)); // 저장해 둔 마지막 버텍스의 현재 좌표값인 curPos 에 (0, -20, 0)을 더해서, 즉 y축으로 -20씩 빼주면 이 버텍스가 어느 방향으로 움직이나 보려는 것.
    triangle.setVertex(2, curPos + glm::vec3(-20, 0, 0)); // 이번에는 (-20, 0, 0) 을 더해서 x축으로 -20씩 빼줘서 버텍스가 어디루 가나 보려는 것.
}

//--------------------------------------------------------------
void ofApp::keyReleased(int key){

}

//--------------------------------------------------------------
void ofApp::mouseMoved(int x, int y ){

}

//--------------------------------------------------------------
void ofApp::mouseDragged(int x, int y, int button){

}

//--------------------------------------------------------------
void ofApp::mousePressed(int x, int y, int button){

}

//--------------------------------------------------------------
void ofApp::mouseReleased(int x, int y, int button){

}

//--------------------------------------------------------------
void ofApp::mouseEntered(int x, int y){

}

//--------------------------------------------------------------
void ofApp::mouseExited(int x, int y){

}

//--------------------------------------------------------------
void ofApp::windowResized(int w, int h){

}

//--------------------------------------------------------------
void ofApp::gotMessage(ofMessage msg){

}

//--------------------------------------------------------------
void ofApp::dragEvent(ofDragInfo dragInfo){ 

}
