#include "ofApp.h"

//--------------------------------------------------------------
// ofApp() 객체를 생성할 때 호출되는 함수 -> 리소스나 렌더링할 대상(메쉬)를 생성하기 적합한 곳.
void ofApp::setup(){
    /**
     ofMesh 객체를 triangle 이라는 변수에 넣어 새롭게 생성함.
     
     근데 왜 이거를 선언해놨다가 주석처리 했을까?
     
     이거를 아래에 있는 ofApp의 draw() 함수에서도
     가져가서 그 안의 .draw() 함수를 호출해야 실행창에서 실제로 메쉬를 렌더링할 수 있음.
     
     근데 draw() 함수에서는 그냥 바로 triangle 변수에 접근을 못함.
     왜? draw() 함수에서 선언한 변수가 아니니까!
     
     이 변수에 접근하고 싶으면, .h 라고 되어있는, cpp 언어에서
     '헤더 파일' 이라고 하는 파일에다가 변수를 선언해주면 됨.
     
     이게 뭐냐면 cpp 에서는
     함수 및 변수의 declaration (선언) 과 definition (정의) 를
     각각의 파일에 나눠서 사용하는 경향이 있음.
     
     즉, .h 인 헤더파일에서는 함수나 변수를 선언만 해주고,
     그 안의 디테일한 로직을 정의하는 건 .cpp 파일에서 해준다는 거임.
     
     이렇게 선언파트를 따로 분리해두면 뭐가 좋냐면,
     .cpp 파일들이 각자 독립적인 컴파일 프로세스, 즉 독립적인 빌드가 가능하다는 것임.
     
     자세한 내용은 유튜브에서 <헤더파일의 의미> 영상 참고할 것.
     
     암튼, 지금 서로 다른 블록의 함수들에서 동일한 ofMesh 객체가 담긴 변수
     triangle 을 사용하고 싶은 거니까, 해당 변수의 선언을
     헤더파일인 ofApp.h 로 옮기면 ofApp의 draw() 함수 안에서도
     triangle 에 접근할 수 있게 됨.
     */
    // ofMesh triangle;
    
    // 각 버텍스의 위치 좌표값을 NDC 좌표계를 기준으로 변경함. p.54 참고
    triangle.addVertex(glm::vec3(-1.0f, 1.0f, 0.0f));
    triangle.addVertex(glm::vec3(-1.0f, -1.0f, 0.0f));
    triangle.addVertex(glm::vec3(1.0f, -1.0f, 0.0f));
    
    // 각 버텍스에 색상데이터를 새로 추가해 줌. -> 이걸 어려운 말로 '버텍스 속성(vertex attribute)을 추가한다'고 함
    triangle.addColor(ofFloatColor(1.0f, 0.0f, 0.0f, 1.0f));
    triangle.addColor(ofFloatColor(0.0f, 1.0f, 0.0f, 1.0f));
    triangle.addColor(ofFloatColor(0.0f, 0.0f, 1.0f, 1.0f));
    
    /**
     ofShader 객체에게 bin/data 폴더에서 작성한 셰이더 파일들을 사용하도록
     해당 파일들을 .load() 함수로 불러오도록 함.
     
     이 때, load() 함수에 인자로 넣어주는 셰이더 파일 경로는
     bin/data 디렉토리를 기준으로 한 상대경로이기 때문에,
     해당 셰이더 파일들을 bin/data 디렉토리 안에 넣어줬다면,
     별도의 경로를 작성할 필요 없이 파일 이름만 써주면 됨.
     
     그래서 책에서 bin/data 에 굳이 셰이더 파일을 넣어두라고 헀던 것임.
     */
    shader.load("first_vertex.vert", "first_fragment.frag");
}

//--------------------------------------------------------------
void ofApp::update(){

}

//--------------------------------------------------------------
// setup() 함수에서 생성한 메쉬들을 실행창 화면에 실제로 그리려면,
// 이 draw() 함수 내에서 각 메쉬들 내부에 존재하는 ofMesh.draw() 내장함수들을 호출해줘야 함.
// 이 draw() 함수는 매 프레임마다 호출되는 three.js 에서 사용하던 렌더링루프 함수랑 똑같다고 보면 됨.
// 매 프레임마다 GPU 에 뭘 그리라고 명령할건지, 그 명령할 내용들을 담아주는 렌더링루프 함수!
void ofApp::draw(){
    /**
     특정 셰이더를 이용해서 메쉬를 렌더링하고자 한다면,
     해당 메쉬에 대한 드로우콜을 보내기 전에
     
     '어떤 셰이더를 사용해서 메쉬를 그릴 건지'  알려줘야 하는데,
     이거를 어려운 말로 '셰이더 바인딩' 한다고 함.
     
     오픈프레임웍스에서는 이 작업을 해주는 함수가
     ofShader.begin() 이라고 보면 됨,
     
     이제 바인딩 이후부터 드로우콜을 호출한 메쉬들은
     바인딩된 셰이더를 적용해서 화면에 렌더된다고 보면 됨,
     */
    shader.begin();
    
    /**
     ofMesh 객체인 triangle에도 .draw() 함수가 따로 존재함.
     
     이거는 뭐냐면, 특정 프레임에 해당 메쉬를 실행창에 그려주라고
     GPU 에 명령을 내리는 내장함수로 보면 됨.
     
     -> 이처럼 GPU 에 특정 메쉬를 그리라고 지시하는 명령을 그래픽 용어로 '드로우콜' 이라고 함!
     그래서 화면에 그리려는 메쉬의 개수를 많이 생성할수록 드로우콜도 그에 비례해서 늘어남.
     이것이 성능 최적화에 중요한 영향을 미침!
     
     JS API 4.0 관련해서 최적화 리서치할 때 배웠지!
     
     이거를 ofApp 의 draw 함수에서 실행하기 위해 triangle 에 대한 접근이
     필요했던 것이고, 그래서 triangle 변수를 헤더 파일에서 선언해준 거임.
     */
    triangle.draw();
    
    /**
     메쉬를 그리는 작업을 모두 끝냈거나,
     다른 셰이더를 사용하고 싶다면,
     
     현재 바인딩된 셰이더의 사용을 중지하라고 GPU 에 명령을 내려야 함.
     이 때 사용하는 오픈프레임웍스 함수가
     ofShader.end() 라고 보면 됨.
     */
    shader.end();
}

//--------------------------------------------------------------
// 키보드 입력을 받으면 호출되는 함수
void ofApp::keyPressed(int key){
    /**
     키보드 입력을 받으면 triangle 메쉬에서 2번째 인덱스의 버텍스,
     즉, 맨 마지막에 추가한 버텍스(0, 1, 2 니까)를 가져와서,
     걔의 y좌표값을 -20 씩 감소시킴으로써, 현재 사용중인 스크린 픽셀 좌표계가
     어떻게 이루어져있는 것인지 확인하기 위한 것임.
     
     이걸 왜 해주냐면, 오픈프레임웍스는 셰이더를 별도로 지정하지 않으면
     기본 셰이더를 적용해주는데, 이 기본 셰이더가 '스크린 픽셀 좌표계' 를 기준으로
     버텍스 좌표를 잡아주고 있음.
     
     근데 이 스크린 픽셀 좌표계는, 마치 2DCanvas 나 DOM 좌표계처럼
     좌측 상단이 (0, 0) 이고, y축이 아래로 갈수록 늘어나는 구조로 되어있어서
     일반 3D 좌표계와 다르다는 것을 인지하기 위해 해보는거임.
     
     지금 아무 키나 누를 때마다 마지막에 추가한 버텍스, 그니까 우측 하단 버텍스를 가져와서
     (0, -20, 0) 버텍스와 더해주는, 그니까 y좌표값을 -20씩 빼주고 있는거임.
     
     이렇게 해서 해당 버텍스가 키를 누를 때마다 어디루 가는지 보면서
     스크린 픽셀 좌표계에서 y축이 어떻게 생겨먹은건지 파악할 수 있음.
     */
    glm::vec3 curPos = triangle.getVertex(2); // 2번째 인덱스의 버텍스, 즉, 마지막에 추가한 버텍스를 가져와서 curPos 에 저장해 둠.
    // triangle.setVertex(2, curPos + glm::vec3(0, -20, 0)); // 저장해 둔 마지막 버텍스의 현재 좌표값인 curPos 에 (0, -20, 0)을 더해서, 즉 y축으로 -20씩 빼주면 이 버텍스가 어느 방향으로 움직이나 보려는 것.
    // triangle.setVertex(2, curPos + glm::vec3(-20, 0, 0)); // 이번에는 (-20, 0, 0) 을 더해서 x축으로 -20씩 빼줘서 버텍스가 어디루 가나 보려는 것.
    
    // setup() 함수에서 각 버텍스 위치 좌표값을 NDC 좌표계를 기준으로 변경해줬으니
    // 키 입력을 받을 때마다 마지막 버텍스를 x축 방향으로 빼주는 값 역시 NDC 좌표계를 기준으로 한 값만큼을 빼줘야겠지
    triangle.setVertex(2, curPos + glm::vec3(-0.1f, 0.0f, 0.0f));
}

//--------------------------------------------------------------
void ofApp::keyReleased(int key){

}

//--------------------------------------------------------------
void ofApp::mouseMoved(int x, int y ){

}

//--------------------------------------------------------------
void ofApp::mouseDragged(int x, int y, int button){

}

//--------------------------------------------------------------
void ofApp::mousePressed(int x, int y, int button){

}

//--------------------------------------------------------------
void ofApp::mouseReleased(int x, int y, int button){

}

//--------------------------------------------------------------
void ofApp::mouseEntered(int x, int y){

}

//--------------------------------------------------------------
void ofApp::mouseExited(int x, int y){

}

//--------------------------------------------------------------
void ofApp::windowResized(int w, int h){

}

//--------------------------------------------------------------
void ofApp::gotMessage(ofMessage msg){

}

//--------------------------------------------------------------
void ofApp::dragEvent(ofDragInfo dragInfo){ 

}
